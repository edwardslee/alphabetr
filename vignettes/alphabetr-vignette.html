<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Edward S. Lee" />

<meta name="date" content="2016-11-07" />

<title>Using ALPHABETR to determine alpha/beta TCR pairs</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Using ALPHABETR to determine alpha/beta TCR pairs</h1>
<h4 class="author"><em>Edward S. Lee</em></h4>
<h4 class="date"><em>2016-11-07</em></h4>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<div id="a-brief-welcome" class="section level2">
<h2>A Brief Welcome</h2>
<p>Welcome to the <code>alphabetr</code> vignette! We’ve spent a lot of time trying to develop a TCR sequencing approach that is more scaleable than single-cell sequencing, and we’re excited for others to use our approach. My hope is that this vignette will be clear and transparent in showing how we thought to solve this problem, not as be-all panacea for our sequencing woes but as one step towards the field closer to a gold standard. The main purpose of this vignette is to demonstrate how to obtain the results of our paper<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> and how to do simulations of your own.</p>
</div>
<div id="immunology-background" class="section level2">
<h2>Immunology background</h2>
<p>T cell receptors (TCR) are heterodimers of two chains, an alpha chain and a beta chain. Identifying TCRs of T cell clones at a minimum requires the identification of the pair of CDR3 sequences of the alpha and beta chains.</p>
</div>
</div>
<div id="overview-of-the-code" class="section level1">
<h1>Overview of the code</h1>
<p>We’ll start by looking at an overview of how to run the <code>alphabetr</code> functions on the sequencing data and then look at the parameters used to simulate the sequencing data.</p>
<div id="importing-data" class="section level2">
<h2>Importing data</h2>
<p>Sequencing data obtained with the alphabetr approach can be imported into R using the <code>read_alphabetr()</code> function.</p>
</div>
<div id="processing-the-sequencing-data" class="section level2">
<h2>Processing the sequencing data</h2>
<p>Our goals are to:</p>
<ol style="list-style-type: decimal">
<li>Determine alpha-beta candidate pairs</li>
<li>Discriminate between dual-alpha TCR clones and beta-sharing clones</li>
<li>Estimate clonal frequencies</li>
</ol>
<p><strong>Determining candidate pairs.</strong> We input the sequencing data into <code>bagpipe()</code>, which determines candidate alpha-beta pairs. The output of <code>bagpipe()</code> determines pairs consisting of only one alpha and one beta.</p>
<p><strong>Discriminating dual-alpha and beta-sharing clones.</strong> We then utilize <code>freq_estimate()</code>and then use those estimates in the <code>dual_top()</code>/<code>dual_tail()</code> functions. Although it seems backwards to estimate clonal frequencies before determining dual-alpha clones, <code>dual_top()</code>/<code>dual_tail()</code> need these frequencies to determine the dual clones<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <code>dual_top()</code>/<code>dual_tail()</code> will then tell us which candidates that share the same beta are actually one clone express both alpha chains.</p>
<p><strong>Estimating clonal frequencies.</strong> The final list of candidate clones, which includes both single-alpha and dual-alpha clones, is then passed into <code>freq_estimate()</code> in order to get a final list of frequen estimates and 95% frequency confidence intervals. The package includes some helper functions to amend the original list of candidate pairs with the newly determined dual-alpha clones (used below in the rest of the vignette).</p>
<!-- ```{r echo = FALSE, out.width = 650, fig.retina = NULL, fig.cap = "Figure 1"} -->
<!-- knitr::include_graphics("overview.png") -->
<!-- ``` -->
</div>
<div id="simulating-sequencing-data" class="section level2">
<h2>Simulating sequencing data</h2>
<p>Simulating the experimental data involves choosing parameters for two domains:</p>
<ol style="list-style-type: decimal">
<li>The clonal structure of the T cell population of interest</li>
<li>The sequencing experiment</li>
</ol>
<!-- Both are described in Figure . -->
<p><strong>Clonal structure.</strong> We create a T cell population using the function <code>create_clones()</code>, which is fully described below, so all I want to do is illustrate what <em>degree of sharing</em> means. Suppose the clones in Figure represent our population of interest. We have four unique alpha chains (a1, a2, a3, a4), one of which is shared by two clones (a2 is shared by a2b1, a2b3). In this population, 25% of the alpha chains are shared by two clones, and 75% of the alpha chains are not shared.</p>
<p><strong>Simulating the sequencing experiment.</strong> Just a remark that there’s a lot of parameters to simulate on the experimental side of things.</p>
</div>
</div>
<div id="running-the-code" class="section level1">
<h1>Running the code</h1>
<p>This section of the vignette will show you how to run simulations from start to finish in order to obtain the type of results as shown in the paper. We will first create T cell populations with user-specified attributes, use functions in <code>alphabetr</code> to figure our candidates pairs, discriminate between dual-alpha and beta-sharing clones, and then determine clonal frequencies.</p>
<div id="installing-and-loading-alphabetr" class="section level2">
<h2>Installing and loading alphabetr</h2>
<p>The package is currently not on CRAN and must be installed from github. The easiet way to do this is through the <code>devtools</code> package. If you don’t have <code>devtools</code> installed, run the following</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;devtools&quot;</span>)</code></pre></div>
<p>With <code>devtools</code> installed, install alphabetr by running</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">devtools::<span class="kw">install_github</span>(<span class="st">&quot;edwardslee/alphabetr&quot;</span>)</code></pre></div>
<p>And then load the package by running</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(alphabetr)</code></pre></div>
</div>
<div id="creating-the-clonal-structure-of-the-t-cell-population" class="section level2">
<h2>Creating the clonal structure of the T cell population</h2>
<p><code>create_clones()</code> will create a T cell population with a structure specified by you. The attributes that can be changed are</p>
<ol style="list-style-type: decimal">
<li>The number of unique beta chains</li>
<li>The proportion of clones with dual beta chains</li>
<li>The proportion of clones with dual alpha chains</li>
<li>The degree of alpha sharing (the proportion of clones that share 1-7 alpha chains)</li>
<li>The degree of beta sharing (the proportion of clones that share 1-5 beta chains)</li>
</ol>
<p>In order to create a population containing</p>
<ul>
<li>1000 unique beta chains</li>
<li>5% of clones with dual beta TCRs</li>
<li>30% of clones with dual alpha TCRs</li>
<li>beta-sharing: 75% beta shared by one clone, 20% by two clones, 5% by three clones</li>
<li>alpha-sharing: 80% alpha chains shared by one clone, 15% by two clones, and 5% by three clones</li>
</ul>
<p>We run the following</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">290</span>)   <span class="co"># to make the results reproducible</span>
clonal &lt;-<span class="st"> </span><span class="kw">create_clones</span>(<span class="dt">numb_beta =</span> <span class="dv">1000</span>,
                        <span class="dt">dual_beta =</span> <span class="fl">0.05</span>,
                        <span class="dt">dual_alpha =</span> .<span class="dv">3</span>,
                        <span class="dt">alpha_sharing =</span> <span class="kw">c</span>(<span class="fl">0.80</span>, <span class="fl">0.15</span>, <span class="fl">0.05</span>),
                        <span class="dt">beta_sharing  =</span> <span class="kw">c</span>(<span class="fl">0.75</span>, <span class="fl">0.20</span>, <span class="fl">0.05</span>))</code></pre></div>
<p>The function arguments are fairly straightforward: <code>numb_beta</code> is the number of unique beta chains in the population, <code>dual</code> is the proportion of clones with dual alpha chains, and <code>alpha_sharing</code> and <code>beta_sharing</code> are the vectors that represent the degree of sharing. Position <code>i</code> of the sharing vectors represent the proportion of the chains shared by <code>i</code> clones.</p>
<p>The output is a list containing different useful versions of the clonal structure</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Clones ordered by beta index</span>
ordered_clones &lt;-<span class="st"> </span>clonal$ordered

<span class="co"># Clones randomly ordered in order to assign random clonal frequencies later </span>
random_clones &lt;-<span class="st"> </span>clonal$TCR

<span class="co"># Clones that express two different alpha chains and two different beta chains</span>
dual_alpha &lt;-<span class="st"> </span>clonal$dual_alpha
dual_beta  &lt;-<span class="st"> </span>clonal$dual_beta</code></pre></div>
<p>Each of these are 3 column matrices, where each row represents a clone, the first column is the beta chain index, and the second and third columns are the alpha indices. If the clone expresses only one alpha chain, then the 2nd and 3rd columns will be equal. For example,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># single TCR clones</span>
random_clones[<span class="dv">5</span>:<span class="dv">7</span>, ]
<span class="co">#&gt;      beta1 beta2 alpha1 alpha2</span>
<span class="co">#&gt; [1,]   383   383    519    519</span>
<span class="co">#&gt; [2,]   753   753   1031   1031</span>
<span class="co">#&gt; [3,]   353   353   1121   1121</span>

<span class="co"># dual TCR-alpha clones</span>
random_clones[<span class="dv">49</span>:<span class="dv">50</span>, ]
<span class="co">#&gt;      beta1 beta2 alpha1 alpha2</span>
<span class="co">#&gt; [1,]   477   477    372    116</span>
<span class="co">#&gt; [2,]   645   645    851    123</span>

<span class="co"># dual TCR-beta clones</span>
random_clones[<span class="dv">47</span>:<span class="dv">48</span>, ]
<span class="co">#&gt;      beta1 beta2 alpha1 alpha2</span>
<span class="co">#&gt; [1,]   821   318    287    287</span>
<span class="co">#&gt; [2,]   408   170    638    638</span></code></pre></div>
<p>For the paper, the clonal structures were created with the following code</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sharing vectors; with this, 1692 beta chains results in 2100 unique clones</span>
share_alph &lt;-<span class="st"> </span><span class="kw">c</span>(.<span class="dv">816</span>, .<span class="dv">085</span>, .<span class="dv">021</span>, .<span class="dv">007</span>, .<span class="dv">033</span>, .<span class="dv">005</span>, .<span class="dv">033</span>)
share_beta &lt;-<span class="st"> </span><span class="kw">c</span>(.<span class="dv">859</span>, .<span class="dv">076</span>, .<span class="dv">037</span>, .<span class="dv">019</span>, .<span class="dv">009</span>)

<span class="co"># Creating a population of 2100 clones with specified sharing and</span>
<span class="co"># 30% dual-alpha clones and 6% dual-beta clones</span>
<span class="kw">set.seed</span>(<span class="dv">258</span>)   <span class="co"># reproducibility for the vignette</span>
TCR_pairings &lt;-<span class="st"> </span><span class="kw">create_clones</span>(<span class="dt">numb_beta =</span> <span class="dv">1787</span>,
                              <span class="dt">dual_beta =</span> <span class="fl">0.06</span>,
                              <span class="dt">dual_alpha =</span> <span class="fl">0.3</span>,
                              <span class="dt">alpha_sharing =</span> share_alph,
                              <span class="dt">beta_sharing =</span> share_beta)
TCR_clones &lt;-<span class="st"> </span>TCR_pairings$TCR</code></pre></div>
<p>We’ll use <code>TCR_clones</code>, which contains the clones in random order, in the next section to simulate sequencing data.</p>
</div>
<div id="simulating-a-tcr-sequencing-experiment" class="section level2">
<h2>Simulating a TCR sequencing experiment</h2>
<p>Now that we’ve created the clones with their alpha and beta sequences (with each unique chain represented by an integer/index), we can simulate sequencing data. We do this by using the function <code>create_data()</code>. <code>create_data()</code> will sample the clones from a skewed distribution into the wells of 96-well plates, which is what would happen in a sequencing experiment by staining T cells with tetramer and using a sorter to sample them into plates.</p>
<p>A number of experimental parameters can be changed to simulate different experimental settings. These parameters and their corresponding arguments in <code>create_data()</code> are</p>
<ol style="list-style-type: decimal">
<li><code>plates</code>: the number of 96-well plates used in the experiment</li>
<li><code>error_drop</code>: a vector that contains the mean error “drop-out” rate and the standard deviation of the error rate (if using a lognormal error model). The drop rate is the probability that the chains of a clone can fail to be sequenced (and thus not appear in our final data set)</li>
</ol>
<ul>
<li>This is a vector of length 2, where the first element is the mean, and the second element is the standard deviation</li>
<li>The first element of <code>error_mode</code> determines whether the error rates are constant or drawn from a lognormal distribution</li>
<li>If you specify a constant rate, then the function will ignore the standard deviation element specified for <code>error_drop</code></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li><code>error_seq</code>: a vector that contains the mean “in-frame” sequencing error rate and the standard deviation of the error rate if using a lognormal error model. This is the probability that a given chain will be sequenced incorrectly and produce an incorrect “false” sequence (which cannot distinguished from “true” sequences).</li>
</ol>
<ul>
<li>As above with <code>error_drop</code>, this argument is a vector of length 2 where the first element is the mean and the second element is the standard deviation</li>
<li>The second element of <code>error_mode</code> determines whether the error rates are constant or drawn from a lognormal distribution</li>
<li>If you specify a constant rate, then the function will ignore the standard deviation element specified for <code>error_drop</code></li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li><code>error_mode</code>: a vector that specifies the error model of the drop errors and the in-frame errors</li>
</ol>
<ul>
<li>The first element of the vector specifies the drop errors</li>
<li>The second element of the vector specifies the in-frame errors</li>
<li>The options are <code>&quot;constant&quot;</code> for a constant error model or <code>&quot;lognormal&quot;</code> for error rates drawn from a lognormal distribution</li>
</ul>
<ol start="5" style="list-style-type: decimal">
<li><code>skewed</code>: the number of clones that represent the “top proportion” of the population in frequency; this top “proportion” is specified in the <code>pct_top</code> argument</li>
<li><code>prop_top</code>: the proportion of the population by frequency that is represented by the top clones (of which there are <code>skewed</code> number of them)</li>
<li><code>dist</code>: to developed in the future, but this option controls the shape of the frequency distribution; always set to <code>&quot;linear&quot;</code> for now</li>
<li><code>numb_cells</code>: sampling strategy that keeps track of the sample sizes of the wells; more details below</li>
</ol>
<p><code>create_data()</code> takes a matrix of clones as an input, such as <code>TCR_clones</code>, and the order the clones appear in this matrix determines their relative frequencies. The first <code>skewed</code> number of rows of the input matrix is used as the clones representing the top proportion of the population, and <code>create_data()</code> internally distributes them in a descending, linear way across the top. The other clones of the tail then have the same frequency, all adding up to the tail proportion of the population.</p>
<p>To illustrate this better, if we were to pass <code>skewed = 25</code> and <code>prop_top = 0.6</code> into <code>create_data()</code>, then the clones represented by the first 25 rows of <code>TCR_clones</code> make up the top 60% of the population, and the other 2075 clones make the other 40% of the population.</p>
<p>The <code>numb_cells</code> argument is a 2 column matrix, where for each row, the 1st column represents the sample size in the well, and the 2nd column is the number of wells with that sample size. You must ensure that the number of wells specified by <code>numb_cells</code> is equal to <code>96 * number_plates</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 5 plates (= 480 wells), every well has a sample size of 50 cells</span>
numb_cells &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">50</span>, <span class="dv">480</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)

<span class="co"># 1 plate (= 96 wells), 48 wells with 100 cells/well, 48 wells with 200 cells/well</span>
numb_cells &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">48</span>, <span class="dv">48</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)</code></pre></div>
<p>Here are the parameters used in the paper with the “high-mixed” sampling strategy:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Different experimental parameters</span>
number_plates &lt;-<span class="st"> </span><span class="dv">5</span>        <span class="co"># five 96-well plates</span>
err_drop &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.15</span>, .<span class="dv">01</span>)  <span class="co"># drop error rate distribution ~ lognormal(.15, .1)</span>
err_seq  &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.02</span>, .<span class="dv">005</span>) <span class="co"># in frame error rate dist ~ lognormal(.02, .005)</span>
err_mode &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;constant&quot;</span>, <span class="st">&quot;constant&quot;</span>) <span class="co"># lognormal error distributions</span>
number_skewed &lt;-<span class="st"> </span><span class="dv">25</span>       <span class="co"># 25 clones representing the top proportion of population</span>
pct_top &lt;-<span class="st"> </span><span class="fl">0.5</span>            <span class="co"># top of population represents 50% of population</span>
dis_behavior &lt;-<span class="st"> &quot;linear&quot;</span>  <span class="co"># only option avaiable is linear at the moment</span>

<span class="co"># Mixed sampling strategy: 128 wells of 20 cells/well, 64 wells of 50 cells/well,</span>
<span class="co"># 96 wells of 100 cells/well, 200 cells/well, 300 cells/well each</span>
numb_cells &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">20</span>,  <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>,
                       <span class="dv">128</span>, <span class="dv">64</span>,  <span class="dv">96</span>,  <span class="dv">96</span>,  <span class="dv">96</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)

<span class="co"># Creating the data sets</span>
data_tcr &lt;-<span class="st"> </span><span class="kw">create_data</span>(<span class="dt">TCR =</span> TCR_clones,
                        <span class="dt">plates =</span> number_plates,
                        <span class="dt">error_drop =</span> err_drop,
                        <span class="dt">error_seq =</span> err_seq,
                        <span class="dt">error_mode =</span> err_mode,
                        <span class="dt">skewed =</span> number_skewed,
                        <span class="dt">prop_top =</span> pct_top,
                        <span class="dt">dist =</span> dis_behavior,
                        <span class="dt">numb_cells =</span> numb_cells)

<span class="co"># Saving the data for alpha chains and data for beta chains</span>
data_alph &lt;-<span class="st"> </span>data_tcr$alpha
data_beta &lt;-<span class="st"> </span>data_tcr$beta</code></pre></div>
<p>The output of <code>create_data()</code> is a list, and the <code>alpha</code> and <code>beta</code> components contain the data for alpha chains and beta chains respectively. Each is a matrix where the rows represent the columns represent the chain indices and the row represents the well. If a well contains a chain, then the row representing that well has a 1 in the chain’s column and 0 if the well does not contain that chain (e.g. if well #25 contains beta 20, then <code>data_beta[25, 20]</code> is 1).</p>
</div>
<div id="finding-candidate-pairs" class="section level2">
<h2>Finding candidate pairs</h2>
<p>Now that we’ve created the data set, we can begin to apply the algorithms to determine TCRs. The default parameters should work sufficiently well for most data sets</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Normally you would want to set rep = 100 or more</span>
pairs &lt;-<span class="st"> </span><span class="kw">bagpipe</span>(<span class="dt">alpha =</span> data_alph, <span class="dt">beta =</span> data_beta, <span class="dt">rep =</span> <span class="dv">5</span>)</code></pre></div>
<p>The output of <code>bagpipe</code> is a matrix with the candidate pairs and the proportion of replicates that each candidate pair appears in.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(pairs)
<span class="co">#&gt;      beta1 beta2 alpha1 alpha2 prop_replicates</span>
<span class="co">#&gt; [1,]     1     1    272    272             1.0</span>
<span class="co">#&gt; [2,]     3     3    935    935             1.0</span>
<span class="co">#&gt; [3,]     4     4    351    351             0.2</span>
<span class="co">#&gt; [4,]     4     4    935    935             0.6</span>
<span class="co">#&gt; [5,]     4     4   1118   1118             0.2</span>
<span class="co">#&gt; [6,]     5     5    714    714             1.0</span></code></pre></div>
<p>You can clearly see that all of the candidate pairs are single TCR clones at this point. We will attempt to determine dual TCR clones later on in the vignette.</p>
<p>Before moving on, you may choose to the filter the candidate pairs with a threshold of the proportion of replicates that a candidate pair must appear in. Increasing the threshold will significantly decrease the false pairing rate (i.e. the rate at which incorrect pairs are identified) while sacrificing depth of the tail and depth of dual TCR-alpha clone identification.</p>
<p>Our own simulations seem to indicate that a threshold of 0.3 to 0.5 gives a good balance of false pairing rate, tail depth, and dual depth:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># remove candidate pairs that don't appear in more than 30% of replicates</span>
pairs &lt;-<span class="st"> </span>pairs[pairs[, <span class="st">&quot;prop_replicates&quot;</span>] &gt;<span class="st"> </span>.<span class="dv">3</span>, ]
<span class="kw">head</span>(pairs)
<span class="co">#&gt;      beta1 beta2 alpha1 alpha2 prop_replicates</span>
<span class="co">#&gt; [1,]     1     1    272    272             1.0</span>
<span class="co">#&gt; [2,]     3     3    935    935             1.0</span>
<span class="co">#&gt; [3,]     4     4    935    935             0.6</span>
<span class="co">#&gt; [4,]     5     5    714    714             1.0</span>
<span class="co">#&gt; [5,]     6     6   1045   1045             1.0</span>
<span class="co">#&gt; [6,]     7     7    258    258             1.0</span></code></pre></div>
</div>
<div id="performing-frequency-estimation-on-these-pairs" class="section level2">
<h2>Performing frequency estimation on these pairs</h2>
<p>With the candidate alpha/beta pairs, we perform an initial frequency estimation as though each candidate pair represents a distinct clone. This is an immediately incorrect assumption because at this point: dual-alpha clones are represented as two distinct clones that share the same beta chain (e.g. if <span class="math inline">\(\beta_1, \alpha_1, \alpha_2\)</span> is a dual clone, then we will have two candidate pairs <span class="math inline">\(\beta_1, \alpha_1\)</span> and <span class="math inline">\(\beta_1, \alpha_2\)</span> at this point). We use the estimated frequencies in order to discriminate between beta-sharing clones and dual-alpha clones.</p>
<p>In order to perform frequency estimation, we use <code>freq_estimate()</code>. The arguments <code>alpha</code> and <code>beta</code> require the sequencing data sets about alpha and beta chains respectively; <code>pair</code> takes the output of <code>bagpipe</code>; <code>error</code> is the experimental error dropout rate; and <code>cells</code> is the sample sizes of the wells and the number of wells with those sample sizes (in the same format as <code>numb_cells</code> in <code>bagpipe()</code>).</p>
<p>Using the data and output of <code>bagipe()</code> from above, we perform frequency estimation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">freq_init &lt;-<span class="st"> </span><span class="kw">freq_estimate</span>(<span class="dt">alpha =</span> data_alph,
                           <span class="dt">beta =</span> data_beta,
                           <span class="dt">pair =</span> pairs,
                           <span class="dt">error =</span> <span class="fl">0.15</span>,
                           <span class="dt">numb_cells =</span> numb_cells)
<span class="kw">head</span>(freq_init)
<span class="co">#&gt;   beta1 beta2 alpha1 alpha2          MLE        CI_up       CI_low</span>
<span class="co">#&gt; 1     1     1    272    272 0.0003040555 0.0005074374 0.0001747017</span>
<span class="co">#&gt; 2     3     3    935    935 0.0002265519 0.0003916560 0.0001105269</span>
<span class="co">#&gt; 3     4     4    935    935 0.0003258786 0.0005390270 0.0001923780</span>
<span class="co">#&gt; 4     5     5    714    714 0.0003066693 0.0005094431 0.0001754589</span>
<span class="co">#&gt; 5     6     6   1045   1045 0.0003258786 0.0005380399 0.0001920682</span>
<span class="co">#&gt; 6     7     7    258    258 0.0003079321 0.0004802097 0.0001577869</span>
<span class="co">#&gt;      CI_length pct_replicates</span>
<span class="co">#&gt; 1 0.0003327357            1.0</span>
<span class="co">#&gt; 2 0.0002811291            1.0</span>
<span class="co">#&gt; 3 0.0003466491            0.6</span>
<span class="co">#&gt; 4 0.0003339843            1.0</span>
<span class="co">#&gt; 5 0.0003459717            1.0</span>
<span class="co">#&gt; 6 0.0003224229            1.0</span></code></pre></div>
<p>You can see that the output shows you the alpha and beta indices of the clone, the frequency point estimate (under <code>MLE</code>), the upper and lower limits of the 95% confidence interval (<code>CI_up</code> and <code>CI_low</code> respectively), the length of the confidence interval, and the number of replicates each clone was found in during <code>bagpipe()</code>.</p>
</div>
<div id="discriminating-beta-sharing-and-dual-tcr-alpha-clones" class="section level2">
<h2>Discriminating beta-sharing and dual TCR-alpha clones</h2>
<p>In order to disciminate between beta-sharing and dual-alpha clones, we needed the frequency estimation of the candidate pairs given by <code>bagpipe()</code>, and the estimated frequencies are used to parse between these situations. Two different functions are needed for this: <code>dual_top()</code> is used to usually determine dual-alpha TCRs in more common clones, and <code>dual_tail()</code> is used to determine dual TCR-alpha TCRs in rare clones in the tail.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># determining duals in the top; note the use of the error rate</span>
common_dual &lt;-<span class="st"> </span><span class="kw">dual_top</span>(<span class="dt">alpha =</span> data_alph,
                        <span class="dt">beta =</span> data_beta,
                        <span class="dt">pair =</span> freq_init,
                        <span class="dt">error =</span> err,
                        <span class="dt">numb_cells =</span> numb_cells)

<span class="co"># determining duals in the tail; note that this does NOT use the error rate</span>
tail_dual &lt;-<span class="st"> </span><span class="kw">dual_tail</span>(<span class="dt">alpha =</span> data_alph,
                       <span class="dt">beta =</span> data_beta,
                       <span class="dt">freq_results =</span> freq_init,
                       <span class="dt">numb_cells =</span> numb_cells)</code></pre></div>
<p>The arguments of these functions are the same arguments used before.</p>
<p>We combine the output of both functions to obtain a data frame with all of the dual clones:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">clones_dual &lt;-<span class="st"> </span><span class="kw">rbind</span>(common_dual, tail_dual)
<span class="kw">head</span>(clones_dual)
<span class="co">#&gt;   beta1 beta2 alpha1 alpha2</span>
<span class="co">#&gt; 1   258   258   1643    892</span>
<span class="co">#&gt; 2   570   570    373    141</span>
<span class="co">#&gt; 3   616   616   1280    648</span>
<span class="co">#&gt; 4   740   740    373   1280</span>
<span class="co">#&gt; 5  1205  1205     33    335</span>
<span class="co">#&gt; 6  1584  1584    944    141</span></code></pre></div>
</div>
<div id="final-frequency-estimation" class="section level2">
<h2>Final frequency estimation</h2>
<p>Now that we identified dual TCR-alpha clones, all that’s left is to estimate their frequencies and replace the corresponding beta-sharing candidate pairs with the dual TCR-alpha clone:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Find the frequencies of the newly identified dual clones</span>
freq_dual &lt;-<span class="st"> </span><span class="kw">freq_estimate</span>(<span class="dt">alpha =</span> data_alph,
                           <span class="dt">beta =</span> data_beta,
                           <span class="dt">pair =</span> clones_dual,
                           <span class="dt">error =</span> <span class="fl">0.15</span>,
                           <span class="dt">numb_cells =</span> numb_cells)

<span class="co"># Remove the candidate beta-sharing clones and replace with the dual clones</span>
tcrpairs &lt;-<span class="st"> </span><span class="kw">combine_freq_results</span>(freq_init, freq_dual)</code></pre></div>
<p><code>combine_freq_results()</code> is a helper function that will combine the initial frequency results and the freshly calculated dual frequency results. It will find the two rows containing the candidate pairs that derived from the dual clone and replace it with the results of the dual clone. The first argument is the initial frequency results, and the second argument is the dual frequency results.</p>
<p>The final results of processing our TCR sequencing data is contained in our data frame <code>tcrpairs</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(tcrpairs)
<span class="co">#&gt;   beta1 beta2 alpha1 alpha2        MLE      CI_up     CI_low  CI_length</span>
<span class="co">#&gt; 1  1637  1637    373   1032 0.04271497 0.04651125 0.03201378 0.01449746</span>
<span class="co">#&gt; 2   258   258   1643    892 0.04146939 0.04507328 0.03123586 0.01383743</span>
<span class="co">#&gt; 3   801   801   1643   1643 0.04083954 0.04767091 0.03491152 0.01275939</span>
<span class="co">#&gt; 4   616   616   1280    648 0.04002182 0.04353211 0.02995146 0.01358065</span>
<span class="co">#&gt; 5   917   917    373    373 0.03696094 0.04328901 0.03151756 0.01177145</span>
<span class="co">#&gt; 6   605   605    157    157 0.03674642 0.04295367 0.03138863 0.01156504</span>
<span class="co">#&gt;   pct_replicates</span>
<span class="co">#&gt; 1           -1.0</span>
<span class="co">#&gt; 2           -1.0</span>
<span class="co">#&gt; 3            1.0</span>
<span class="co">#&gt; 4           -1.0</span>
<span class="co">#&gt; 5            0.6</span>
<span class="co">#&gt; 6            1.0</span></code></pre></div>
<p>Note that if a clone is dual, then the <code>pct_replicates</code> column is set to -1.</p>
</div>
<div id="evaluation-of-results" class="section level2">
<h2>Evaluation of results</h2>
<p>Two functions are included in the package to evaluate the performance of the frequency estimation and the dual discrimination. The function <code>dual_eval()</code> is used to determine how well the dual discrimination went.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dual_res &lt;-<span class="st"> </span><span class="kw">dual_eval</span>(<span class="dt">duals =</span> clones_dual,
                      <span class="dt">pair =</span> freq_init,
                      <span class="dt">TCR =</span> TCR_pairings$TCR,
                      <span class="dt">number_skewed =</span> number_skewed,
                      <span class="dt">TCR_dual =</span> TCR_pairings$dual_alpha)

<span class="co"># listing the false dual rate and the adjusted dual depths of the top and tail clones</span>
dual_res$fdr
<span class="co">#&gt; [1] 0.1946309</span>
dual_res$adj_depth_top
<span class="co">#&gt; [1] 0.8</span>
dual_res$adj_depth_tail
<span class="co">#&gt; [1] 0.9586777</span></code></pre></div>
<p>The function <code>freq_eval()</code> is used to determine how precise the frequency estimates are and how many 95% confidence intervals contain the true clonal frequency.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">freq_res &lt;-<span class="st"> </span><span class="kw">freq_eval</span>(<span class="dt">freq =</span> tcrpairs,
                      <span class="dt">number_skewed =</span> number_skewed,
                      <span class="dt">TCR =</span> TCR_pairings$TCR,
                      <span class="dt">numb_clones =</span> <span class="kw">nrow</span>(TCR_pairings$TCR),
                      <span class="dt">prop_top =</span> pct_top)

<span class="co"># CV of estimates and the proportion of CIs with correct frequency</span>
freq_res$cv
<span class="co">#&gt; [1] 0.08575125</span>
freq_res$correct
<span class="co">#&gt; [1] 0.84</span></code></pre></div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Paper was submitted recently<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>see the paper to understand the mathematics that’s going on.<a href="#fnref2">↩</a></p></li>
</ol>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
